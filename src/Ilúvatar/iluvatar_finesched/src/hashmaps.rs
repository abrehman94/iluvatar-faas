// this is from autogenerated code
pub use crate::bpf_skel::bpf_hashmaps::*;

use std::fmt::{Debug, Formatter};
use std::fs;
use std::mem::MaybeUninit;
use std::path::Path;

use libbpf_rs::skel::OpenSkel;
use libbpf_rs::skel::SkelBuilder;
use libbpf_rs::MapCore;
use libbpf_rs::MapFlags;
use libbpf_rs::MapMut;
use libbpf_rs::OpenMapMut;
use libbpf_rs::OpenObject;

use crate::CgroupChrs;
use crate::SchedGroupChrs;
use crate::SchedGroupID;
use crate::SchedGroupStats;

use crate::bpf_intf::consts_MAX_PATH;

static mut open_object: MaybeUninit<OpenObject> = MaybeUninit::<OpenObject>::uninit();

pub static CGROUP_MAP_PATH: &str = "/sys/fs/bpf/cMap";
pub static SCHED_GROUP_MAP_PATH: &str = "/sys/fs/bpf/gMap";
pub static SCHED_GROUP_STATS_MAP_PATH: &str = "/sys/fs/bpf/gStats";

pub fn rm_pinned_map<'obj>(path: &str) -> bool {
    if Path::new(path).exists() {
        fs::remove_file(path).expect(format!("failed to remove map {}", path).as_str());
        return true;
    }
    false
}

pub fn reuse_pinned_map<'obj>(map: &mut OpenMapMut<'obj>, path: &str) -> bool {
    if Path::new(path).exists() {
        assert!(map.reuse_pinned_map("/asdf").is_err());
        map.reuse_pinned_map(path).expect("failed to reuse map");
        return true;
    }
    false
}

pub fn pin_map<'obj>(map: &mut MapMut<'obj>, path: &str) {
    map.pin(path).expect("failed to pin map");
    assert!(Path::new(path).exists());
}

fn str_to_clipped_cstr(s: &str) -> [u8; consts_MAX_PATH as usize] {
    let mut cstr = [0u8; consts_MAX_PATH as usize];
    for (i, c) in s.bytes().enumerate() {
        if i >= cstr.len() {
            break;
        }
        cstr[i] = c as u8;
    }
    cstr
}

/// # Safety
/// This function takes the reference and generates a raw pointer to the data.
/// It should be used with caution as it can lead to undefined behavior if the data is not valid.
pub unsafe fn any_as_u8_slice<T: Sized>(p: &T) -> &[u8] {
    ::core::slice::from_raw_parts((p as *const T) as *const u8, ::core::mem::size_of::<T>())
}

pub trait CMAP {
    fn insert(&mut self, key: &str, value: &CgroupChrs);
    fn lookup(&self, key: &str) -> Option<CgroupChrs>;
}

pub trait GMAP {
    fn insert(&mut self, key: &SchedGroupID, value: &SchedGroupChrs);
    fn lookup(&self, key: &SchedGroupID) -> Option<SchedGroupChrs>;
}

pub trait GStats {
    fn lookup(&self, key: &SchedGroupID) -> Option<SchedGroupStats>;
}

pub struct SharedMaps<'obj> {
    skel: BpfHashmapsSkel<'obj>,
}

impl Debug for SharedMaps<'_> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("BpfHashmapsSkel").finish()
    }
}

impl CMAP for SharedMaps<'_> {
    fn insert(&mut self, key: &str, value: &CgroupChrs) {
        println!("inserting {:?} {:?}", key, value);
        let map = &mut self.skel.maps.cMap;
        let key = &str_to_clipped_cstr(key);
        let val: &[u8] = unsafe { any_as_u8_slice(value) };
        match map.update(key, val, MapFlags::ANY) {
            Ok(_) => (),
            Err(e) => {
                println!("error: unable to update the map {:?}", e);
            }
        }
    }

    fn lookup(&self, key: &str) -> Option<CgroupChrs> {
        println!("looking up {}", key);
        let map = &self.skel.maps.cMap;
        let key = &str_to_clipped_cstr(key);
        match map.lookup(key, MapFlags::ANY) {
            Ok(byts) => match byts {
                Some(byts) => {
                    let cgroup_chrs: CgroupChrs = unsafe { *(byts.as_ptr() as *const CgroupChrs) };
                    Some(cgroup_chrs)
                }
                None => {
                    println!("error: didn't find {:?}", key);
                    None
                }
            },
            Err(e) => {
                println!("error: didn't find {:?} error {:?}", key, e);
                None
            }
        }
    }
}

impl GMAP for SharedMaps<'_> {
    fn insert(&mut self, key: &SchedGroupID, value: &SchedGroupChrs) {
        println!("inserting {:?} {:?}", key, value);
        let map = &mut self.skel.maps.gMap;
        let key: &[u8] = unsafe { any_as_u8_slice(key) };
        let val: &[u8] = unsafe { any_as_u8_slice(value) };
        match map.update(key, val, MapFlags::ANY) {
            Ok(_) => (),
            Err(e) => {
                println!("error: unable to update the map {:?}", e);
            }
        }
    }

    fn lookup(&self, key: &SchedGroupID) -> Option<SchedGroupChrs> {
        println!("looking up {}", key);
        let map = &self.skel.maps.gMap;
        let key: &[u8] = unsafe { any_as_u8_slice(key) };
        match map.lookup(key, MapFlags::ANY) {
            Ok(byts) => match byts {
                Some(byts) => {
                    let schedg_chrs: SchedGroupChrs = unsafe { *(byts.as_ptr() as *const SchedGroupChrs) };
                    Some(schedg_chrs)
                }
                None => {
                    println!("error: didn't find {:?}", key);
                    None
                }
            },
            Err(e) => {
                println!("error: didn't find {:?} error {:?}", key, e);
                None
            }
        }
    }
}

impl GStats for SharedMaps<'_> {
    fn lookup(&self, key: &SchedGroupID) -> Option<SchedGroupStats> {
        println!("looking up {}", key);
        let map = &self.skel.maps.gStats;
        let key: &[u8] = unsafe { any_as_u8_slice(key) };
        match map.lookup(key, MapFlags::ANY) {
            Ok(byts) => match byts {
                Some(byts) => {
                    let stats: SchedGroupStats = unsafe { *(byts.as_ptr() as *const SchedGroupStats) };
                    Some(stats)
                }
                None => {
                    println!("error: didn't find {:?}", key);
                    None
                }
            },
            Err(e) => {
                println!("error: didn't find {:?} error {:?}", key, e);
                None
            }
        }
    }
}

impl SharedMaps<'_> {
    pub fn new() -> Self {
        let mut skel_builder = BpfHashmapsSkelBuilder::default();
        skel_builder.obj_builder.debug(true);
        let open_skel = unsafe { skel_builder.open(&mut open_object).unwrap() };

        rm_pinned_map(CGROUP_MAP_PATH);
        rm_pinned_map(SCHED_GROUP_MAP_PATH);
        rm_pinned_map(SCHED_GROUP_STATS_MAP_PATH);

        let mut skel = open_skel.load().unwrap();

        pin_map(&mut skel.maps.cMap, CGROUP_MAP_PATH);
        pin_map(&mut skel.maps.gMap, SCHED_GROUP_MAP_PATH);
        pin_map(&mut skel.maps.gStats, SCHED_GROUP_STATS_MAP_PATH);

        SharedMaps { skel: skel }
    }
}
